<!doctype html><html><head><meta charset=utf-8><title>JMESPath</title><link href=https://unpkg.com/sanitize.css rel=stylesheet><link rel=stylesheet href=https://jmespath.site/main.min.6e37f92ea129dfb8ac2ae07fbbcb6c818d56949be122a248177c60771215ada4.css integrity="sha256-bjf5LqEp37isKuB/u8tsgY1WlJvhIqJIF3xgdxIVraQ="><link rel=stylesheet href=https://jmespath.site/demo.min.1eff893cd3b6264167cd7b59682cf6bda28ccfad8a2ef8ab923d12aa5f6aaf6f.css integrity="sha256-Hv+JPNO2JkFnzXtZaCz2vaKMz62KLvirkj0Sql9qr28="><script type=text/javascript src=https://jmespath.blob.core.windows.net/lib/v1.1.3/jmespath.umd.min.js integrity=sha384-KzTAbBrAddBOX0gCk9cZNsYH1n5ot1g+hVqmZs1FNN7Qk2xs2orwcMVsnzvyP+8I crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://jmespath.site/demo.340f4852640bc4f5848e413b1bb1a8effb133ca876334acd26cff69285728722.js integrity="sha256-NA9IUmQLxPWEjkE7G7Go7/sTPKh2M0rNJs/2koVyhyI="></script></head><body><header></header><main><h1 id=wiki-lexical-scopes>Lexical Scopes</h1><p>JMESPath Community introduces the <a href=https://github.com/jmespath-community/jmespath.spec/blob/main/jep-011a-lexical-scope.md target=_blank rel=noopener><code>let-expression</code></a>
function
to supports nested lexical scopes.</p><pre tabindex=0><code>let $foo = bar in {a: myvar, b: $foo}
</code></pre><p>The first argument is a JSON object that introduces a new lexical scope.</p><p>The second argument is an <code>expression-type</code> that is evaluated against the current context – <em>i.e</em> the current result of JMESPath evaluation context, that can be referred to by the <code>@</code> node. The <code>expression-type</code> also has access to the stack of nested scopes.</p><p>Consider the following example:</p><div class="demo active" onclick=demo(event) class=active><input type=text class=query oninput=demoInput(event) value="let $first_choice = first_choice in states[?name == $first_choice].cities[]"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{&#34;first_choice&#34;: &#34;WA&#34;,
 &#34;states&#34;: [
   {&#34;name&#34;: &#34;WA&#34;, &#34;cities&#34;: [&#34;Seattle&#34;, &#34;Bellevue&#34;, &#34;Olympia&#34;]},
   {&#34;name&#34;: &#34;CA&#34;, &#34;cities&#34;: [&#34;Los Angeles&#34;, &#34;San Francisco&#34;]},
   {&#34;name&#34;: &#34;NY&#34;, &#34;cities&#34;: [&#34;New York City&#34;, &#34;Albany&#34;]}
 ]
}</textarea>
<textarea class=result readonly></textarea></div><p>When evaluating the <code>states</code> identifier, JMESPath no longer has access to the root scope, where <code>first_choice</code> is defined. Therefore, under normal circumstances, the <code>filter-expression</code> <code>[?name === first_choice]</code> would evaluate the <code>first_choice</code> identifier and return an empty array.</p><p>Instead, <code>let()</code> defined the identifier <code>first_choice</code> has taking the value of the property with the same name in the input JSON document. It effectively created a scope that can be represented as the following JSON object:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{ <span style=color:#062873;font-weight:700>&#34;first_choice&#34;</span>: <span style=color:#4070a0>&#34;WA&#34;</span> }
</span></span></code></pre></div><p>Therefore, when evaluating the <code>filter-expression</code>, the <code>first_choice</code> identifier is indeed defined, and produces the correct result.</p><h2 id=wiki-arithmetic-expressions>Arithmetic Expressions</h2><p>JMESPath Community now supports <a href=https://github.com/jmespath-community/jmespath.spec/discussions/25#discussioncomment-3277652 target=_blank rel=noopener><code>arithmetic-expression</code></a>
syntax with the usual operators.</p><div class="demo active" onclick=demo(event) class=active><input type=text class=query oninput=demoInput(event) value="{ a: a, b: b, c: b × `2` } | a ÷ ( b − c)"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;a&#34;: 40,
  &#34;b&#34;: 2
}</textarea>
<textarea class=result readonly>-20</textarea></div><h2 id=wiki-object-manipulation-functions>Object Manipulation Functions</h2><p>As a JSON query language, JMESPath Community now supports <a href=https://github.com/jmespath-community/jmespath.spec/discussions/47#discussioncomment-3308897 target=_blank rel=noopener>functions to manipulate JSON objects</a>
.</p><p>The <code>items()</code> function allows you to <em>deconstruct</em> a JSON object to its key and values,
whereas the <code>from_items()</code> function will combine two arrays into a single JSON object.</p><div class="demo active" onclick=demo(event) class=active><input type=text class=query oninput=demoInput(event) value="from_items(items(@))"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;foo&#34;: &#34;lorem&#34;,
  &#34;bar&#34;: &#34;ipsum&#34;,
  &#34;baz&#34;: &#34;dolor&#34;
}</textarea>
<textarea class=result readonly>{
  &#34;bar&#34;: &#34;ipsum&#34;, &#34;baz&#34;: &#34;dolor&#34;, &#34;foo&#34;: &#34;lorem&#34;
}</textarea></div><p>The <code>zip()</code> function comes the Python language. It combines two or more arrays into a set of arrays,
each of which contains the _i_th indexed item from each indivual array.</p><p>For better understanding, consider the following example:</p><div class="demo active" onclick=demo(event) class=active><input type=text class=query oninput=demoInput(event) value="zip(people, country, fruits)"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;fruits&#34;: [&#34;Orange&#34;, &#34;Apple&#34;, &#34;Strawberry&#34;],
  &#34;people&#34;: [&#34;John&#34;, &#34;Marc&#34;, &#34;Paul&#34;],
  &#34;country&#34;: [&#34;Germany&#34;, &#34;France&#34;, &#34;USA&#34; ]
}</textarea>
<textarea class=result readonly>[
  [
    &#34;John&#34;, &#34;Germany&#34;, &#34;Orange&#34;
  ], [
    &#34;Marc&#34;, &#34;France&#34;, &#34;Apple&#34;
  ], [
    &#34;Paul&#34;, &#34;USA&#34;, &#34;Strawberry&#34;
  ]
]</textarea></div><p>Think of the three <code>fruits</code>, <code>people</code> and <code>country</code> arrays as being <em>rows</em> in a table.
Each array has a number of items that you can think of as being the <em>columns</em> in the table.</p><p>The <code>zip()</code> function will create as many arrays as there are full columns, each of which
will contain the items found in each row of the table.</p><p>So, the first array – corresponding to the first column of the table – will contain
one item from the <code>people</code> row, one item from the <code>country</code> row and finally one item from the <code>fruits</code> row,
resulting in <code>["John", "Germany", "Orange"]</code>.</p><p>The second array – corresponding to the second column of the table – contains <code>["Marc", "France", "Apple"]</code>.</p><h2 id=wiki-string-slices>String Slices</h2><p>Using <code>slice-expression</code> to slice strings is popular in modern programming languages. JMESPath Community supports slicing strings using the same syntax:</p><div class="demo active" onclick=demo(event) class=active><input type=text class=query oninput=demoInput(event) value="foo[:4]"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;foo&#34;: &#34;Hello, world!&#34;,
  &#34;bar&#34;: [&#34;h&#34;, &#34;e&#34;, &#34;l&#34;, &#34;l&#34;, &#34;o&#34;, &#34; &#34;, &#34;w&#34;, &#34;o&#34;, &#34;r&#34;, &#34;l&#34;, &#34;d&#34;, &#34;!&#34;]
}</textarea>
<textarea class=result readonly>&#34;Hell&#34;</textarea></div><p><strong>Note</strong>: <code>slice-expression</code> applied to JSON arrays result in a <em>projection</em>. Applying a <code>slice-expression</code> to a JSON string, however, produces a JSON string.</p><h2 id=wiki-groups>Groups</h2><p>Using the <a href=https://github.com/jmespath-community/jmespath.spec/discussions/96#discussion-4282156 target=_blank rel=noopener><code>group_by()</code> function</a>
, you can group collection of objects with specific criteria:</p><div class="demo active" onclick=demo(event) class=active><input type=text class=query oninput=demoInput(event) value="group_by(items, &amp;spec.nodeName)"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;items&#34;: [
    { &#34;spec&#34;: { &#34;nodeName&#34;: &#34;node_01&#34;, &#34;other&#34;: &#34;values_01&#34; } },
    { &#34;spec&#34;: { &#34;nodeName&#34;: &#34;node_02&#34;, &#34;other&#34;: &#34;values_02&#34; } },
    { &#34;spec&#34;: { &#34;nodeName&#34;: &#34;node_03&#34;, &#34;other&#34;: &#34;values_03&#34; } },
    { &#34;spec&#34;: { &#34;nodeName&#34;: &#34;node_01&#34;, &#34;other&#34;: &#34;values_04&#34; } }
  ]
}</textarea>
<textarea class=result readonly>{
  &#34;node_01&#34;: [
    {
      &#34;spec&#34;: {
        &#34;nodeName&#34;: &#34;node_01&#34;, &#34;other&#34;: &#34;values_01&#34;
      }
    }, {
      &#34;spec&#34;: {
        &#34;nodeName&#34;: &#34;node_01&#34;, &#34;other&#34;: &#34;values_04&#34;
      }
    }
  ], &#34;node_02&#34;: [
    {
      &#34;spec&#34;: {
        &#34;nodeName&#34;: &#34;node_02&#34;, &#34;other&#34;: &#34;values_02&#34;
      }
    }
  ], &#34;node_03&#34;: [
    {
      &#34;spec&#34;: {
        &#34;nodeName&#34;: &#34;node_03&#34;, &#34;other&#34;: &#34;values_03&#34;
      }
    }
  ]
}</textarea></div></main><footer></footer></body></html>