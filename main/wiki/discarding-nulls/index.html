<!doctype html><html><head><meta charset=utf-8><title>JMESPath</title><link href=https://unpkg.com/sanitize.css rel=stylesheet><link rel=stylesheet href=https://jmespath.site/main.min.6e37f92ea129dfb8ac2ae07fbbcb6c818d56949be122a248177c60771215ada4.css integrity="sha256-bjf5LqEp37isKuB/u8tsgY1WlJvhIqJIF3xgdxIVraQ="><link rel=stylesheet href=https://jmespath.site/demo.min.1eff893cd3b6264167cd7b59682cf6bda28ccfad8a2ef8ab923d12aa5f6aaf6f.css integrity="sha256-Hv+JPNO2JkFnzXtZaCz2vaKMz62KLvirkj0Sql9qr28="><script type=text/javascript src=https://jmespath.blob.core.windows.net/lib/v1.1.0/jmespath.umd.min.js integrity=sha384-t7065c25LTxBEFgHVZMrh6eQmEPcySOYMfPn75zeZV+lP7fwYtEELuFFgFc42rkZ crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://jmespath.site/demo.340f4852640bc4f5848e413b1bb1a8effb133ca876334acd26cff69285728722.js integrity="sha256-NA9IUmQLxPWEjkE7G7Go7/sTPKh2M0rNJs/2koVyhyI="></script></head><body><header></header><main><h2 id=wiki-problem-statement>Problem statement</h2><p>Discarding <code>null</code> values is a surprisingly frequently requested feature from JMESPath.
The canonical answer is to use the <code>merge()</code> function and let external deserializers discard / ignore those values.</p><p>That said, the <code>items()</code>, <code>from_items()</code> and <code>zip()</code> functions let you build primitives to achieve this.</p><h2 id=wiki-how-to>How to</h2><p>Given:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{ <span style=color:#062873;font-weight:700>&#34;a&#34;</span>: <span style=color:#40a070>1</span>, <span style=color:#062873;font-weight:700>&#34;b&#34;</span>: <span style=color:#4070a0>&#34;&#34;</span>, <span style=color:#062873;font-weight:700>&#34;c&#34;</span>: <span style=color:#007020;font-weight:700>null</span> }
</span></span></code></pre></div><p>The following expressions can be useful:</p><ul><li><code>from_items( items(@) [? @[1]!=`null` ] )</code> returns `` { &ldquo;a&rdquo;: 1, &ldquo;b&rdquo;: "" }</li><li><code>from_items( items(@) [? @[1]!='' ] )</code> returns `` { &ldquo;a&rdquo;: 1, &ldquo;c&rdquo;: null }</li><li><code>from_items( items(@) [? @[1] ] )</code> returns `` { &ldquo;a&rdquo;: 1 }</li></ul><h3 id=wiki-more-complex-objects>More complex objects</h3><p>The previous primitives can be used in more complex scenarios where the discarded values are in nested object structures.</p><p>Given:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#062873;font-weight:700>&#34;key1&#34;</span>: { <span style=color:#062873;font-weight:700>&#34;a&#34;</span>: <span style=color:#40a070>1</span>, <span style=color:#062873;font-weight:700>&#34;b&#34;</span>: <span style=color:#4070a0>&#34;&#34;</span>, <span style=color:#062873;font-weight:700>&#34;c&#34;</span>: <span style=color:#007020;font-weight:700>null</span> },
</span></span><span style=display:flex><span>	<span style=color:#062873;font-weight:700>&#34;key2&#34;</span>: { <span style=color:#062873;font-weight:700>&#34;a&#34;</span>: <span style=color:#40a070>2</span>, <span style=color:#062873;font-weight:700>&#34;b&#34;</span>: <span style=color:#4070a0>&#34;bee&#34;</span>, <span style=color:#062873;font-weight:700>&#34;c&#34;</span>: <span style=color:#4070a0>&#34;&#34;</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This requires a way to split keys from their values, operate on the values using one of the primitives referred to above, and reconstruct the object.</p><p>The following expressions are needed:</p><ul><li><code>keys(@)</code> to extract the key from the object.</li><li><code>values(@)[*].from_items( items(@)[?@[1]] )</code> to discard all <em>falsy</em> values, that include both <code>null</code> and empty strings.</li></ul><p>Given those two expressions, the <code>let()</code> function lets you create a scope to hold both keys and computed values, and operate on them using an <code>expression-type</code>:</p><p><code>let( { k:keys(@), v:values(@)[*].from_items( items(@)[?@[1]] ) }, &â€¦ )</code></p><p>The first argument to the <code>let()</code> function creates a <code>multi-select-hash</code> scope with two properties, <code>k</code> and <code>v</code> that hold the keys from the original input and the newly computed values respectively.</p><p>The second argument to the <code>let()</code> function is an <code>expression-type</code> that can be used to operate on said scope object.</p><p>To reconstruct an object from a given set of keys and values, use the following expression:</p><p><code>from_items( { k:k, v:v }.zip(k, v) )</code></p><blockquote><p><strong>Note</strong>: the <code>let()</code> function is currently being discussed and subject to change. However, lexical scoping using some form of a let expression will still be possible.</p></blockquote></main><footer></footer></body></html>