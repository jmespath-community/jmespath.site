<!doctype html><html><head><meta charset=utf-8><title>JMESPath</title><link href=https://unpkg.com/sanitize.css rel=stylesheet><link rel=stylesheet href=https://jmespath.site/main.min.6e37f92ea129dfb8ac2ae07fbbcb6c818d56949be122a248177c60771215ada4.css integrity="sha256-bjf5LqEp37isKuB/u8tsgY1WlJvhIqJIF3xgdxIVraQ="><link rel=stylesheet href=https://jmespath.site/demo.min.1eff893cd3b6264167cd7b59682cf6bda28ccfad8a2ef8ab923d12aa5f6aaf6f.css integrity="sha256-Hv+JPNO2JkFnzXtZaCz2vaKMz62KLvirkj0Sql9qr28="><script type=text/javascript src=https://jmespath.blob.core.windows.net/lib/v1.1.3/jmespath.umd.min.js integrity=sha384-KzTAbBrAddBOX0gCk9cZNsYH1n5ot1g+hVqmZs1FNN7Qk2xs2orwcMVsnzvyP+8I crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://jmespath.site/demo.340f4852640bc4f5848e413b1bb1a8effb133ca876334acd26cff69285728722.js integrity="sha256-NA9IUmQLxPWEjkE7G7Go7/sTPKh2M0rNJs/2koVyhyI="></script></head><body><header></header><main><p>JMESPath is a query language for JSON. You can extract and transform elements from a JSON
document. The examples below are interactive. You can change the
JMESPath expressions and see the results update automatically.</p><p>For each of these examples, the JMESPath expression is applied to the
input JSON on the left, and the result of evaluating the JMESPath
expression is shown in the JSON document on the right-hand side.</p><h1 id=wiki-basic-expressions>Basic Expressions</h1><p>The simplest JMESPath expression is an <code>identifier</code>, which selects a key in an JSON object:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=a></input>
<textarea class=data rows=10 oninput=demoInput(event)>{&#34;a&#34;: &#34;foo&#34;, &#34;b&#34;: &#34;bar&#34;, &#34;c&#34;: &#34;baz&#34;}</textarea>
<textarea class=result readonly>&#34;foo&#34;</textarea></div><p>Try changing the expression above to <code>b</code>, and <code>c</code> and note the updated
result. Also note that if you refer to a key that does not exist, a
value of <code>null</code> (or the language equivalent of <code>null</code>) is returned.</p><p>You can use a <code>subexpression</code> to return to nested values in a JSON object:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=a.b.c.d></input>
<textarea class=data rows=10 oninput=demoInput(event)>{&#34;a&#34;: {&#34;b&#34;: {&#34;c&#34;: {&#34;d&#34;: &#34;value&#34;}}}}</textarea>
<textarea class=result readonly>&#34;value&#34;</textarea></div><p>If you refer to a key that does not exist, a value of <code>null</code> is
returned. Attempting to subsequently access identifiers will continue to
return a value of <code>null</code>. Try changing the expression to <code>b.c.d.e</code>
above.</p><p><code>Index Expressions</code> allow you to select a specific element in a list. It should look similar
to array access in common programming languages. Indexing is 0 based.</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=[1]></input>
<textarea class=data rows=10 oninput=demoInput(event)>[&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;, &#34;e&#34;, &#34;f&#34;]</textarea>
<textarea class=result readonly>&#34;b&#34;</textarea></div><p>If you specify an index that&rsquo;s larger than the list, a value of <code>null</code>
is returned. You can also use negative indexing to index from the end of
the list. <code>[-1]</code> refers to the last element in the list, <code>[-2]</code> refers
to the penultimate element. Try it out in the example above.</p><p>You can combine identifiers, sub expressions, and index expressions to
access JSON elements.</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=a.b.c[0].d[1][0]></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;a&#34;: {
    &#34;b&#34;: {
      &#34;c&#34;: [
        {
          &#34;d&#34;: [ 0, [ 1, 2 ] ]
        },
        {
          &#34;d&#34;: [ 3, 4 ]
        }
      ]
    }
  }
}</textarea>
<textarea class=result readonly>1</textarea></div><h1 id=wiki-slicing>Slicing</h1><p>Slices allow you to select a contiguous subset of an array. If you&rsquo;ve
ever used slicing in python, then you already know how to use JMESPath
slices. In its simplest form, you can specify the starting index and the
ending index. The ending index is the first index which you do <em>not</em>
want included in the slice. Let&rsquo;s take a look at some examples. First,
given an array of integers from 0 to 9, let&rsquo;s select the first half of
the array:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=[0:5]></input>
<textarea class=data rows=10 oninput=demoInput(event)>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</textarea>
<textarea class=result readonly>[
  0, 1, 2, 3, 4
]</textarea></div><p>This slice result contains the elements 0, 1, 2, 3, and 4. The element
at index 5 is not included. If we want to select the second half of the
array, we can use this expression:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=[5:10]></input>
<textarea class=data rows=10 oninput=demoInput(event)>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</textarea>
<textarea class=result readonly>[
  5, 6, 7, 8, 9
]</textarea></div><p>The two example above can be shortened. If the <code>start</code> or <code>stop</code> value
is omitted it is assumed to be the start or the end of the array. For
example:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=[:5]></input>
<textarea class=data rows=10 oninput=demoInput(event)>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</textarea>
<textarea class=result readonly>[
  0, 1, 2, 3, 4
]</textarea></div><p>Try modifying the example above to only include the last half of the
array elements without specifying the end value of <code>10</code>.</p><p>The general form of a slice is <code>[start:stop:step]</code>. So far we&rsquo;ve looked
at the <code>[start:stop]</code> form. By default, the <code>step</code> value is <code>1</code>, which
means to include every element in the range specified by the <code>start</code> and
<code>stop</code> value. However, we can use the step value to skip over elements.
For example, to select only the even elements from the array.</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=[::2]></input>
<textarea class=data rows=10 oninput=demoInput(event)>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</textarea>
<textarea class=result readonly>[
  0, 2, 4, 6, 8
]</textarea></div><p>Also note in this example we&rsquo;re omitting the <code>start</code> as well as the
<code>stop</code> value, which means to use <code>0</code> for the <code>start</code> value, and <code>10</code> for
the <code>stop</code> value. In this example, the expression <code>[::2]</code> is equivalent
to <code>[0:10:2]</code>.</p><p>The last thing to know about slices is that just like indexing a single
value, all the values can be negative. If the <code>step</code> value is negative,
then the slice is created in reverse order. For example:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=[::-1]></input>
<textarea class=data rows=10 oninput=demoInput(event)>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</textarea>
<textarea class=result readonly>[
  9, 8, 7, 6, 5, 4, 3, 2, 1, 0
]</textarea></div><p>The above expression creates a slice but in reverse order.</p><p>If you want all the details about how slices work, check out the
<a href=https://jmespath.site/#spec-slices target=_blank rel=noopener><code>slices</code></a>
in the specification.</p><h1 id=wiki-projections>Projections</h1><p>Projections are one of the key features of JMESPath. It allows you to
apply an expression to a collection of elements. There are five kinds of
projections:</p><ul><li>List Projections</li><li>Slice Projections</li><li>Object Projections</li><li>Flatten Projections</li><li>Filter Projections</li></ul><h2 id=wiki-list-and-slice-projections>List and Slice Projections</h2><p>A <code>wildcard expression</code>
creates a list projection, which is a projection over a JSON array. This
is best illustrated with an example. Let&rsquo;s say we have a JSON document
describing a people, and each array element is a JSON object that has a
<code>first</code>, <code>last</code>, and <code>age</code> key. Suppose we wanted a list of all the
first names in our list.</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=people[*].first></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;people&#34;: [
    {
      &#34;first&#34;: &#34;James&#34;,
      &#34;last&#34;: &#34;d&#34;
    },
    {
      &#34;first&#34;: &#34;Jacob&#34;,
      &#34;last&#34;: &#34;e&#34;
    },
    {
      &#34;first&#34;: &#34;Jayden&#34;,
      &#34;last&#34;: &#34;f&#34;
    },
    {
      &#34;missing&#34;: &#34;different&#34;
    }
  ],
  &#34;foo&#34;: {
    &#34;bar&#34;: &#34;baz&#34;
  }
}</textarea>
<textarea class=result readonly>[
  &#34;James&#34;, &#34;Jacob&#34;, &#34;Jayden&#34;
]</textarea></div><p>In the example above, the <code>first</code> expression, which is just an
identifier, is applied to each element in the <code>people</code> array. The
results are collected into a JSON array and returned as the result of
the expression. The expression can be more complex than a basic
<code>identifier</code>. For example, the expression <code>foo[*].bar.baz[0]</code> would
project the <code>bar.baz[0]</code> expression to each element in the <code>foo</code> array.</p><p>There&rsquo;s a few things to keep in mind when working with projections.
These are discussed in more detail in the [<code>wildcards</code>] section
of the spec, but the main points are:</p><ul><li>Projections are evaluated as two steps. The left-hand side (LHS)
creates a JSON array of initial values. The right-hand side (RHS) of
a projection is the expression to project for each element in the
JSON array created by the left-hand side. Each projection type has
slightly different semantics when evaluating either the left-hand
side and/or the right-hand side.</li><li>If the result of the expression projected onto an individual array
element is <code>null</code>, then that value is omitted from the collected set
of results.</li><li>You can stop a projection with a Pipe Expression (discussed later).</li><li>A list projection is only valid for a JSON array. If the value is
not a list, then the result of the expression is <code>null</code>.</li></ul><p>You can try this out in the demo above. Notice how <code>people[*].first</code>
only included three elements, even though the people array has four
elements. This is because the last element, <code>{"missing": "different"}</code>
evaluates to <code>null</code> when the expression <code>first</code> is applied, and <code>null</code>
values are not added to the collected result array. If you try the
expression <code>foo[*].bar</code> you&rsquo;ll see a result of <code>null</code>, because the
value associated with the <code>foo</code> key is a JSON object, not an array, and
a list projection is only defined for JSON arrays.</p><p>Slice projections are almost identical to a list projection, with the
exception that the left-hand side is the result of evaluating the slice,
which may not include all the elements in the original list:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=people[:2].first></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;people&#34;: [
    {
      &#34;first&#34;: &#34;James&#34;,
      &#34;last&#34;: &#34;d&#34;
    },
    {
      &#34;first&#34;: &#34;Jacob&#34;,
      &#34;last&#34;: &#34;e&#34;
    },
    {
      &#34;first&#34;: &#34;Jayden&#34;,
      &#34;last&#34;: &#34;f&#34;
    },
    {
      &#34;missing&#34;: &#34;different&#34;
    }
  ],
  &#34;foo&#34;: {
    &#34;bar&#34;: &#34;baz&#34;
  }
}</textarea>
<textarea class=result readonly>[
  &#34;James&#34;, &#34;Jacob&#34;
]</textarea></div><h2 id=wiki-object-projections>Object Projections</h2><p>Whereas a list projection is defined for a JSON array, an object
projection is defined for a JSON object. You can create an object
projection using the <code>*</code> syntax. This will create a list of the values
of the JSON object, and project the right-hand side of the projection
onto the list of values.</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=ops.*.numArgs></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;ops&#34;: {
    &#34;functionA&#34;: {
      &#34;numArgs&#34;: 2
    },
    &#34;functionB&#34;: {
      &#34;numArgs&#34;: 3
    },
    &#34;functionC&#34;: {
      &#34;variadic&#34;: true
    }
  }
}</textarea>
<textarea class=result readonly>[
  2, 3
]</textarea></div><p>In the example above the <code>*</code> creates a JSON array of the values
associated with the <code>ops</code> JSON object. The RHS of the projection,
<code>numArgs</code>, is then applied to the JSON array, resulting in the final
array of <code>[2, 3]</code>. Below is a sample walk-through of how an
implementation could <em>potentially</em> implement evaluating an object
projection. First, the object projection can be broken down into its two
components, the left-hand side (LHS) and its right-hand side (RHS):</p><ul><li><strong>LHS</strong>: <code>ops</code></li><li><strong>RHS</strong>: <code>numArgs</code></li></ul><p>First, the LHS is evaluated to create the initial array to be projected:</p><pre><code>evaluate(ops, inputData) -&gt; [{&quot;numArgs&quot;: 2}, {&quot;numArgs&quot;: 3},
                             {&quot;variadic&quot;: True}]
</code></pre><p>Then the RHS is applied to each element in the array:</p><pre><code>evaluate(numArgs, {numArgs: 2}) -&gt; 2
evaluate(numArgs, {numArgs: 3}) -&gt; 3
evaluate(numArgs, {variadic: true}) -&gt; null
</code></pre><p>Any <code>null</code> values are not included in the final result, so the result of
the entire expression is therefore <code>[2, 3]</code>.</p><h2 id=wiki-flatten-projections>Flatten Projections</h2><p>More than one projection can be used in a JMESPath expression. In the
case of a List/Object projection, the structure of the original document
is preserved when creating projection within a projection. For example,
let&rsquo;s take the expression <code>reservations[*].instances[*].state</code>. This
expression is saying that the top level key <code>reservations</code> has an array
as a value. For each of those array elements, project the
<code>instances[*].state</code> expression. Within each list element, there&rsquo;s an
<code>instances</code> key which itself is a value, and we create a sub projection
for each each list element in the list. Here&rsquo;s an example of that:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=reservations[*].instances[*].state></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;reservations&#34;: [
    {
      &#34;instances&#34;: [
        {
          &#34;state&#34;: &#34;running&#34;
        },
        {
          &#34;state&#34;: &#34;stopped&#34;
        }
      ]
    },
    {
      &#34;instances&#34;: [
        {
          &#34;state&#34;: &#34;terminated&#34;
        },
        {
          &#34;state&#34;: &#34;running&#34;
        }
      ]
    }
  ]
}</textarea>
<textarea class=result readonly>[
  [
    &#34;running&#34;, &#34;stopped&#34;
  ], [
    &#34;terminated&#34;, &#34;running&#34;
  ]
]</textarea></div><p>The result of this expression is <code>[["running", "stopped"], ["terminated", "running"]]</code>, which is a list
of lists. The outer list is from the projection of <code>reservations[*]</code>,
and the inner list is a projection of <code>state</code> created from
<code>instances[*]</code>:</p><pre><code>1st       r0                         r1
2nd i0          i1             i0            i1
[[&quot;running&quot;, &quot;stopped&quot;], [&quot;terminated&quot;, &quot;running&quot;]]
</code></pre><p>What if we just want a list of all the states of our instances? We&rsquo;d
ideally like a result <code>["running", "stopped", "terminated", "running"]</code>.
In this situation, we don&rsquo;t care which reservation the instance
belonged to, we just want a list of states.</p><p>This is the problem that a <code>Flatten Projection</code> solves. To
get the desired result, you can use <code>[]</code> instead of <code>[*]</code> to flatten a
list: <code>reservations[].instances[].state</code>. Try changing <code>[*]</code> to <code>[]</code> in
the expression above and see how the result changes.</p><p>While the <code>flatten</code> spec goes into more detail, a simple rule of thumb to use for the flatten operator,
<code>[]</code>, is that:</p><ul><li>It flattens sublists into the parent list (not recursively, just one
level).</li><li>It creates a projection, so anything on the RHS of the flatten
projection is projected onto the newly created flattened list.</li></ul><p>You can also just use <code>[]</code> on its own to flatten a list:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=[]></input>
<textarea class=data rows=10 oninput=demoInput(event)>[[0, 1], 2, [3], 4, [5, [6, 7]]]</textarea>
<textarea class=result readonly>[
  0, 1, 2, 3, 4, 5, [
    6, 7
  ]
]</textarea></div><p>If you flattened the result of the expression again, <code>[][]</code>, you&rsquo;d then
get a result of <code>[0, 1, 2, 3, 4, 5, 6, 7]</code>. Try it out in the example
above.</p><h2 id=wiki-filter-projections>Filter Projections</h2><p>Up to this point we&rsquo;ve looked at:</p><ul><li>List/Slice projections</li><li>Object projections</li><li>Flatten projections</li></ul><p>Evaluating the RHS of a projection is a basic type of filter. If the
result of the expression evaluated against an individual element results
in <code>null</code>, then the element is excluded from the final result.</p><p>A filter projection allows you to filter the LHS of the projection
<em>before</em> evaluating the RHS of a projection.</p><p>For example, let&rsquo;s say we have a list of machines, each has a <code>name</code>
and a <code>state</code>. We&rsquo;d like the name of all machines that are running. In
pseudocode, this would be:</p><pre><code>result = []
foreach machine in inputData['machines']
  if machine['state'] == 'running'
    result.insert_at_end(machine['name'])
return result
</code></pre><p>A filter projection can be used to accomplish this:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value="machines[?state=='running'].name"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;machines&#34;: [
    {
      &#34;name&#34;: &#34;a&#34;,
      &#34;state&#34;: &#34;running&#34;
    },
    {
      &#34;name&#34;: &#34;b&#34;,
      &#34;state&#34;: &#34;stopped&#34;
    },
    {
      &#34;name&#34;: &#34;b&#34;,
      &#34;state&#34;: &#34;running&#34;
    }
  ]
}</textarea>
<textarea class=result readonly>[
  &#34;a&#34;, &#34;b&#34;
]</textarea></div><p>Try changing <code>running</code> to <code>stopped</code> in the example above. You can also
remove the <code>.name</code> at the end of the expression if you just want the
entire JSON object of each machine that has the specified state.</p><p>A filter expression is defined for an array and has the general form
<code>LHS [? &lt;expression> &lt;comparator> &lt;expression>] RHS</code>. The
<code>filter expression &lt;filterexpressions></code>{.interpreted-text role=&ldquo;ref&rdquo;}
spec details exactly what comparators are available and how they work,
but the standard comparators are supported, i.e <code>==, !=, &lt;, &lt;=, >, >=</code>.</p><h1 id=wiki-pipe-expressions>Pipe Expressions</h1><p>Projections are an important concept in JMESPath. However, there are
times when projection semantics are <em>not</em> what you want. A common
scenario is when you want to operate of the <em>result</em> of a projection
rather than projecting an expression onto each element in the array. For
example, the expression <code>people[*].first</code> will give you an array
containing the first names of everyone in the people array. What if you
wanted the first element in that list? If you tried <code>people[*].first[0]</code>
that you just evaluate <code>first[0]</code> for each element in the people array,
and because indexing is not defined for strings, the final result would
be an empty array, <code>[]</code>. To accomplish the desired result, you can use a
pipe expression, <code>&lt;expression> | &lt;expression></code>, to indicate that a
projection must stop. This is shown in the example below:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value="people[*].first | [0]"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;people&#34;: [
    {
      &#34;first&#34;: &#34;James&#34;,
      &#34;last&#34;: &#34;d&#34;
    },
    {
      &#34;first&#34;: &#34;Jacob&#34;,
      &#34;last&#34;: &#34;e&#34;
    },
    {
      &#34;first&#34;: &#34;Jayden&#34;,
      &#34;last&#34;: &#34;f&#34;
    },
    {
      &#34;missing&#34;: &#34;different&#34;
    }
  ],
  &#34;foo&#34;: {
    &#34;bar&#34;: &#34;baz&#34;
  }
}</textarea>
<textarea class=result readonly>&#34;James&#34;</textarea></div><p>In the example above, the RHS of the list projection is <code>first</code>. When a
pipe is encountered, the result up to that point is passed to the RHS of
the pipe expression. The pipe expression is evaluated as:</p><pre><code>evaluate(people[*].first, inputData) -&gt; [&quot;James&quot;, &quot;Jacob&quot;, &quot;Jayden&quot;]
evaluate([0], [&quot;James&quot;, &quot;Jacob&quot;, &quot;Jayden&quot;]) -&gt; &quot;James&quot;
</code></pre><h1 id=wiki-multiselect>MultiSelect</h1><p>Up to this point, we&rsquo;ve looked at JMESPath expressions that help to
pare down a JSON document into just the elements you&rsquo;re interested in.
This next concept,
<a href=https://jmespath.site/#spec-multiselectlist target=_blank rel=noopener><code>multiselect lists</code></a>
and <a href=https://jmespath.site/#spec-multiselecthash target=_blank rel=noopener><code>multiselect hashes</code></a>
allow you to create JSON elements. This allows you to create elements
that don&rsquo;t exist in a JSON document. A multiselect list creates a list
and a multiselect hash creates a JSON object.</p><p>This is an example of a multiselect list:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value="people[].[name, state.name]"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;people&#34;: [
    {
      &#34;name&#34;: &#34;a&#34;,
      &#34;state&#34;: {
        &#34;name&#34;: &#34;up&#34;
      }
    },
    {
      &#34;name&#34;: &#34;b&#34;,
      &#34;state&#34;: {
        &#34;name&#34;: &#34;down&#34;
      }
    },
    {
      &#34;name&#34;: &#34;c&#34;,
      &#34;state&#34;: {
        &#34;name&#34;: &#34;up&#34;
      }
    }
  ]
}</textarea>
<textarea class=result readonly>[
  [
    &#34;a&#34;, &#34;up&#34;
  ], [
    &#34;b&#34;, &#34;down&#34;
  ], [
    &#34;c&#34;, &#34;up&#34;
  ]
]</textarea></div><p>In the expression above, the <code>[name, state.name]</code> portion is a
multiselect list. It says to create a list of two element, the first
element is the result of evaluating the <code>name</code> expression against the
list element, and the second element is the result of evaluating
<code>state.name</code>. Each list element will therefore create a two element
list, and the final result of the entire expression is a list of two
element lists.</p><p>Unlike a projection, the result of the expression in always included,
even if the result is a null. If you change the above expression to
<code>people[].[foo, bar]</code> each two element list will be <code>[null, null]</code>.</p><p>A multiselect hash has the same basic idea as a multiselect list, except
it instead creates a hash instead of an array. Using the same example
above, if we instead wanted to create a two element hash that had two
keys, <code>Name</code> and <code>State</code>, we could use this:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value="people[].{Name: name, State: state.name}"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;people&#34;: [
    {
      &#34;name&#34;: &#34;a&#34;,
      &#34;state&#34;: {
        &#34;name&#34;: &#34;up&#34;
      }
    },
    {
      &#34;name&#34;: &#34;b&#34;,
      &#34;state&#34;: {
        &#34;name&#34;: &#34;down&#34;
      }
    },
    {
      &#34;name&#34;: &#34;c&#34;,
      &#34;state&#34;: {
        &#34;name&#34;: &#34;up&#34;
      }
    }
  ]
}</textarea>
<textarea class=result readonly>[
  {
    &#34;Name&#34;: &#34;a&#34;, &#34;State&#34;: &#34;up&#34;
  }, {
    &#34;Name&#34;: &#34;b&#34;, &#34;State&#34;: &#34;down&#34;
  }, {
    &#34;Name&#34;: &#34;c&#34;, &#34;State&#34;: &#34;up&#34;
  }
]</textarea></div><h1 id=wiki-functions>Functions</h1><p>JMESPath supports function expressions, for example:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value=length(people)></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;people&#34;: [
    {
      &#34;name&#34;: &#34;b&#34;,
      &#34;age&#34;: 30,
      &#34;state&#34;: {
        &#34;name&#34;: &#34;up&#34;
      }
    },
    {
      &#34;name&#34;: &#34;a&#34;,
      &#34;age&#34;: 50,
      &#34;state&#34;: {
        &#34;name&#34;: &#34;down&#34;
      }
    },
    {
      &#34;name&#34;: &#34;c&#34;,
      &#34;age&#34;: 40,
      &#34;state&#34;: {
        &#34;name&#34;: &#34;up&#34;
      }
    }
  ]
}</textarea>
<textarea class=result readonly>3</textarea></div><p><a href=https://jmespath.site/#functions target=_blank rel=noopener>Functions</a>
can be used to transform and filter data in powerful ways.</p><p>Below are a few examples of functions.</p><p>This example prints the name of the oldest person in the <code>people</code> array:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value="max_by(people, &amp;age).name"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;people&#34;: [
    {
      &#34;name&#34;: &#34;b&#34;,
      &#34;age&#34;: 30
    },
    {
      &#34;name&#34;: &#34;a&#34;,
      &#34;age&#34;: 50
    },
    {
      &#34;name&#34;: &#34;c&#34;,
      &#34;age&#34;: 40
    }
  ]
}</textarea>
<textarea class=result readonly>&#34;a&#34;</textarea></div><p>Functions can also be combined with filter expressions. In the example
below, the JMESPath expressions finds all elements in <code>myarray</code> that
contains the string <code>foo</code>.</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value="myarray[?contains(@, 'foo') == [true]]"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;myarray&#34;: [
    &#34;foo&#34;,
    &#34;foobar&#34;,
    &#34;barfoo&#34;,
    &#34;bar&#34;,
    &#34;baz&#34;,
    &#34;barbaz&#34;,
    &#34;barfoobaz&#34;
  ]
}</textarea>
<textarea class=result readonly>[]</textarea></div><p>The <code>@</code> character in the example above refers to the current element
being evaluated in <code>myarray</code>. The expression <code>contains(@, `foo`)</code>
will return <code>true</code> if the current element in the <code>myarray</code> array
contains the string <code>foo</code>.</p><p>While the <code>function expression</code> spec has all the details, there are a few things to keep in
mind when working with functions:</p><ul><li>Function arguments have types. If an argument for a function has the
wrong type, an <code>invalid-type</code> error will occur. There are functions
that can do type conversions (<code>to_string</code>, <code>to_number</code>) to help get
arguments converted to their proper type.</li><li>If a function is called with the wrong number of arguments, an
<code>invalid-arity</code> will occur.</li></ul><h1 id=wiki-next-steps>Next Steps</h1><p>We&rsquo;ve now seen an overview of the JMESPath language. The next things to
do are:</p><ul><li>See the <a href=https://jmespath.site/#examples target=_blank rel=noopener>examples</a>
. You&rsquo;ll see common
JMESPath expressions that go beyond the tutorial. You&rsquo;ll also see
you how to combine multiple features together in order to best
leverage JMESPath expressions.</li><li>To actually start using JMESPath, pick the language of your choice,
and check out the <a href=https://jmespath.site/#libraries target=_blank rel=noopener>libraries</a>
page for
more information on using JMESPath in the language of your choice.</li><li>Read the <a href=https://jmespath.site/#specification target=_blank rel=noopener>JMESPath Spec</a>
, which
has the official ABNF grammar and full details of the semantics of
the language.</li></ul></main><footer></footer></body></html>