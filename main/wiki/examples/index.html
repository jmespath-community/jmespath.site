<!doctype html><html><head><meta charset=utf-8><title>JMESPath</title><link href=https://unpkg.com/sanitize.css rel=stylesheet><link rel=stylesheet href=https://jmespath.site/main.min.6e37f92ea129dfb8ac2ae07fbbcb6c818d56949be122a248177c60771215ada4.css integrity="sha256-bjf5LqEp37isKuB/u8tsgY1WlJvhIqJIF3xgdxIVraQ="><link rel=stylesheet href=https://jmespath.site/demo.min.1eff893cd3b6264167cd7b59682cf6bda28ccfad8a2ef8ab923d12aa5f6aaf6f.css integrity="sha256-Hv+JPNO2JkFnzXtZaCz2vaKMz62KLvirkj0Sql9qr28="><script src=https://cdnjs.cloudflare.com/ajax/libs/jmespath/0.16.0/jmespath.min.js integrity="sha512-w/sNKK/59oJUi6v+SjgfIijrkFN8Pfv5QFZSV4KvrNMJrlbVM3017ZGNCA2AwZ6PKJzTPxQaDs/TbPcVGnF+pQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://jmespath.site/demo.54010b76c3c7c740235154331141617373dbb05320e38b4862c4acb4637d3f50.js integrity="sha256-VAELdsPHx0AjUVQzEUFhc3PbsFMg44tIYsSstGN9P1A="></script></head><body><header></header><main><h1 id=wiki-filters-and-multiselect-lists>Filters and Multiselect Lists</h1><p>One of the most common usage scenarios for JMESPath is being able to
take a complex JSON document and simplify it down. The main features at
work here are filters and multiselects. In this example below, we&rsquo;re
taking the array of people and, for any element with an age key whose
value is greater than 20, we&rsquo;re creating a sub list of the name and age
values.</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value="people[?age > [20]].[name, age]"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;people&#34;: [
    {
      &#34;age&#34;: 20,
      &#34;other&#34;: &#34;foo&#34;,
      &#34;name&#34;: &#34;Bob&#34;
    },
    {
      &#34;age&#34;: 25,
      &#34;other&#34;: &#34;bar&#34;,
      &#34;name&#34;: &#34;Fred&#34;
    },
    {
      &#34;age&#34;: 30,
      &#34;other&#34;: &#34;baz&#34;,
      &#34;name&#34;: &#34;George&#34;
    }
  ]
}</textarea>
<textarea class=result readonly>[]</textarea></div><h1 id=wiki-filters-and-multiselect-hashes>Filters and Multiselect Hashes</h1><p>In the previous example we were taking an array of hashes, and
simplifying down to an array of two element arrays containing a name and
an age. We&rsquo;re also only including list elements where the <code>age</code> key is
greater than <code>20</code>. If instead we want to create the same hash structure
but only include the <code>age</code> and <code>name</code> key, we can instead say:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value="people[?age > [20]].{name: name, age: age}"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;people&#34;: [
    {
      &#34;age&#34;: 20,
      &#34;other&#34;: &#34;foo&#34;,
      &#34;name&#34;: &#34;Bob&#34;
    },
    {
      &#34;age&#34;: 25,
      &#34;other&#34;: &#34;bar&#34;,
      &#34;name&#34;: &#34;Fred&#34;
    },
    {
      &#34;age&#34;: 30,
      &#34;other&#34;: &#34;baz&#34;,
      &#34;name&#34;: &#34;George&#34;
    }
  ]
}</textarea>
<textarea class=result readonly>[]</textarea></div><p>The last half of the above expression contains key value pairs which
have the general form <code>keyname: &lt;expression></code>. In the above expression
we&rsquo;re just using a field as an expression, but they can be more
advanced expressions. For example:</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value="people[*].{name: name, tags: tags[0]}"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;people&#34;: [
    {
      &#34;age&#34;: 20,
      &#34;tags&#34;: [
        &#34;a&#34;,
        &#34;b&#34;,
        &#34;c&#34;
      ],
      &#34;name&#34;: &#34;Bob&#34;
    },
    {
      &#34;age&#34;: 25,
      &#34;tags&#34;: [
        &#34;d&#34;,
        &#34;e&#34;,
        &#34;f&#34;
      ],
      &#34;name&#34;: &#34;Fred&#34;
    },
    {
      &#34;age&#34;: 30,
      &#34;tags&#34;: [
        &#34;g&#34;,
        &#34;h&#34;,
        &#34;i&#34;
      ],
      &#34;name&#34;: &#34;George&#34;
    }
  ]
}</textarea>
<textarea class=result readonly>[
  {
    &#34;name&#34;: &#34;Bob&#34;, &#34;tags&#34;: &#34;a&#34;
  }, {
    &#34;name&#34;: &#34;Fred&#34;, &#34;tags&#34;: &#34;d&#34;
  }, {
    &#34;name&#34;: &#34;George&#34;, &#34;tags&#34;: &#34;g&#34;
  }
]</textarea></div><p>Notice in the above example instead of applying a filter expression
(<code>[? &lt;expr> ]</code>), we&rsquo;re selecting all array elements via <code>[*]</code>.</p><h1 id=wiki-working-with-nested-data>Working with Nested Data</h1><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value="reservations[].instances[].[tags[?Key=='Name'].Values[] | [0], type, state.name]"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;reservations&#34;: [
    {
      &#34;instances&#34;: [
        {
          &#34;type&#34;: &#34;small&#34;,
          &#34;state&#34;: {
            &#34;name&#34;: &#34;running&#34;
          },
          &#34;tags&#34;: [
            {
              &#34;Key&#34;: &#34;Name&#34;,
              &#34;Values&#34;: [
                &#34;Web&#34;
              ]
            },
            {
              &#34;Key&#34;: &#34;version&#34;,
              &#34;Values&#34;: [
                &#34;1&#34;
              ]
            }
          ]
        },
        {
          &#34;type&#34;: &#34;large&#34;,
          &#34;state&#34;: {
            &#34;name&#34;: &#34;stopped&#34;
          },
          &#34;tags&#34;: [
            {
              &#34;Key&#34;: &#34;Name&#34;,
              &#34;Values&#34;: [
                &#34;Web&#34;
              ]
            },
            {
              &#34;Key&#34;: &#34;version&#34;,
              &#34;Values&#34;: [
                &#34;1&#34;
              ]
            }
          ]
        }
      ]
    },
    {
      &#34;instances&#34;: [
        {
          &#34;type&#34;: &#34;medium&#34;,
          &#34;state&#34;: {
            &#34;name&#34;: &#34;terminated&#34;
          },
          &#34;tags&#34;: [
            {
              &#34;Key&#34;: &#34;Name&#34;,
              &#34;Values&#34;: [
                &#34;Web&#34;
              ]
            },
            {
              &#34;Key&#34;: &#34;version&#34;,
              &#34;Values&#34;: [
                &#34;1&#34;
              ]
            }
          ]
        },
        {
          &#34;type&#34;: &#34;xlarge&#34;,
          &#34;state&#34;: {
            &#34;name&#34;: &#34;running&#34;
          },
          &#34;tags&#34;: [
            {
              &#34;Key&#34;: &#34;Name&#34;,
              &#34;Values&#34;: [
                &#34;DB&#34;
              ]
            },
            {
              &#34;Key&#34;: &#34;version&#34;,
              &#34;Values&#34;: [
                &#34;1&#34;
              ]
            }
          ]
        }
      ]
    }
  ]
}</textarea>
<textarea class=result readonly>[
  [
    &#34;Web&#34;, &#34;small&#34;, &#34;running&#34;
  ], [
    &#34;Web&#34;, &#34;large&#34;, &#34;stopped&#34;
  ], [
    &#34;Web&#34;, &#34;medium&#34;, &#34;terminated&#34;
  ], [
    &#34;DB&#34;, &#34;xlarge&#34;, &#34;running&#34;
  ]
]</textarea></div><p>The above example combines several JMESPath features including the
<a href=https://jmespath.site/#spec-flatten target=_blank rel=noopener><code>flatten</code></a>
operator, multiselect lists, filters, and pipes.</p><p>The input data contains a top level key, &ldquo;reservations&rdquo;, which is a
list. Within each list, there is an &ldquo;instances&rdquo; key, which is also a
list.</p><p>The first thing we&rsquo;re doing here is creating a single list from
multiple lists of instances. By using the <a href=https://jmespath.site/#spec-flatten target=_blank rel=noopener><code>flatten</code></a>
we can take the two instances from the first list and the
two instances from the second list, and combine them into a single list.
Try changing the above expression to just <code>reservations[].instances[]</code>
to see what this flattened list looks like. Everything to the right of
the <code>reservations[].instances[]</code> is about taking the flattened list and
paring it down to contain only the data that we want. This expression is
taking each element in the original list and transforming it into a
three element sublist. The three elements are:</p><ul><li>In the <code>tags</code> list, select the first element in the flattened
<code>Values</code> list whose <code>Key</code> has a value of <code>Name</code>.</li><li>The <code>type</code></li><li>The <code>state.name</code> of each instance.</li></ul><p>The most interesting of those three expressions is the
<code>tags[?Key=='Name'].Values[] | [0]</code> part. Let&rsquo;s examine that further.</p><p>The first thing to notice is that we&rsquo;re filtering down the list
associated with the <code>tags</code> key. The <code>tags[?Key==`Name`]</code> tells us to
only include list elements that contain a <code>Key</code> whose value is <code>Name</code>.
From those filtered list elements we&rsquo;re going to take the <code>Values</code> key
and flatten the list. Finally, the <code>| [0]</code> will take the entire list and
extract the 0th element.</p><h2 id=wiki-filtering-and-selecting-nested-data>Filtering and Selecting Nested Data</h2><p>In this example, we&rsquo;re going to look at how you can filter nested
hashes.</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value="people[?general.id==`100`].general | [0]"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;people&#34;: [
    {
      &#34;general&#34;: {
        &#34;id&#34;: 100,
        &#34;age&#34;: 20,
        &#34;other&#34;: &#34;foo&#34;,
        &#34;name&#34;: &#34;Bob&#34;
      },
      &#34;history&#34;: {
        &#34;first_login&#34;: &#34;2014-01-01&#34;,
        &#34;last_login&#34;: &#34;2014-01-02&#34;
      }
    },
    {
      &#34;general&#34;: {
        &#34;id&#34;: 101,
        &#34;age&#34;: 30,
        &#34;other&#34;: &#34;bar&#34;,
        &#34;name&#34;: &#34;Bill&#34;
      },
      &#34;history&#34;: {
        &#34;first_login&#34;: &#34;2014-05-01&#34;,
        &#34;last_login&#34;: &#34;2014-05-02&#34;
      }
    }
  ]
}</textarea>
<textarea class=result readonly>{
  &#34;age&#34;: 20, &#34;id&#34;: 100, &#34;name&#34;: &#34;Bob&#34;, &#34;other&#34;: &#34;foo&#34;
}</textarea></div><p>In this example we&rsquo;re searching through the <code>people</code> array. Each
element in this array contains a hash of two elements, and each value in
the hash is itself a hash. We&rsquo;re trying to retrieve the value of the
<code>general</code> key that contains an <code>id</code> key with a value of <code>100</code>.</p><p>If we just had the expression <code>people[?general.id==`100`]</code>, we&rsquo;d
have a result of:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>[{
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;general&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#062873;font-weight:700>&#34;id&#34;</span>: <span style=color:#40a070>100</span>,
</span></span><span style=display:flex><span>    <span style=color:#062873;font-weight:700>&#34;age&#34;</span>: <span style=color:#40a070>20</span>,
</span></span><span style=display:flex><span>    <span style=color:#062873;font-weight:700>&#34;other&#34;</span>: <span style=color:#4070a0>&#34;foo&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#062873;font-weight:700>&#34;name&#34;</span>: <span style=color:#4070a0>&#34;Bob&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;history&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#062873;font-weight:700>&#34;first_login&#34;</span>: <span style=color:#4070a0>&#34;2014-01-01&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#062873;font-weight:700>&#34;last_login&#34;</span>: <span style=color:#4070a0>&#34;2014-01-02&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}]
</span></span></code></pre></div><p>Let&rsquo;s walk through how we arrived at this result. In words, the
<code>people[?general.id==`100`]</code> expression is saying &ldquo;for each element
in the people array, select the elements where the <code>general.id</code> equals
<code>100</code>&rdquo;. If we trace the execution of this filtering process we have:</p><pre><code># First element:
    {
      &quot;general&quot;: {
        &quot;id&quot;: 100,
        &quot;age&quot;: 20,
        &quot;other&quot;: &quot;foo&quot;,
        &quot;name&quot;: &quot;Bob&quot;
      },
      &quot;history&quot;: {
        &quot;first_login&quot;: &quot;2014-01-01&quot;,
        &quot;last_login&quot;: &quot;2014-01-02&quot;
      }
    },
# Applying the expression ``general.id`` to this hash::
    100
# Does 100==100?
    true
# Add this first element (in its entirety) to the result list.

# Second element:
    {
      &quot;general&quot;: {
        &quot;id&quot;: 101,
        &quot;age&quot;: 30,
        &quot;other&quot;: &quot;bar&quot;,
        &quot;name&quot;: &quot;Bill&quot;
      },
      &quot;history&quot;: {
        &quot;first_login&quot;: &quot;2014-05-01&quot;,
        &quot;last_login&quot;: &quot;2014-05-02&quot;
      }
    }

# Applying the expression ``general.id`` to this element::
    101
# Does 101==100?
    false
# Do not add this element to the results list.
# Result of this expression is a list containing the first element.
</code></pre><p>However, this still isn&rsquo;t the final value we want which is:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;id&#34;</span>: <span style=color:#40a070>100</span>,
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;age&#34;</span>: <span style=color:#40a070>20</span>,
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;other&#34;</span>: <span style=color:#4070a0>&#34;foo&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;name&#34;</span>: <span style=color:#4070a0>&#34;Bob&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In order to get to this value from our filtered results we need to first
select the <code>general</code> key. This gives us a list of just the values of the
<code>general</code> hash:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>[{
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;id&#34;</span>: <span style=color:#40a070>100</span>,
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;age&#34;</span>: <span style=color:#40a070>20</span>,
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;other&#34;</span>: <span style=color:#4070a0>&#34;foo&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;name&#34;</span>: <span style=color:#4070a0>&#34;Bob&#34;</span>
</span></span><span style=display:flex><span>}]
</span></span></code></pre></div><p>From there, we then uses a pipe (<code>|</code>) to stop projections so that we can
finally select the first element (<code>[0]</code>). Note that we are making the
assumption that there&rsquo;s only one hash that contains an <code>id</code> of <code>100</code>.
Given the way the data is structured, it&rsquo;s entirely possible to have
data such as:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#062873;font-weight:700>&#34;people&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#062873;font-weight:700>&#34;general&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#062873;font-weight:700>&#34;id&#34;</span>: <span style=color:#40a070>100</span>,
</span></span><span style=display:flex><span>        <span style=color:#062873;font-weight:700>&#34;age&#34;</span>: <span style=color:#40a070>20</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:#062873;font-weight:700>&#34;history&#34;</span>: {
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#062873;font-weight:700>&#34;general&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#062873;font-weight:700>&#34;id&#34;</span>: <span style=color:#40a070>101</span>,
</span></span><span style=display:flex><span>        <span style=color:#062873;font-weight:700>&#34;age&#34;</span>: <span style=color:#40a070>30</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:#062873;font-weight:700>&#34;history&#34;</span>: {
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#062873;font-weight:700>&#34;general&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#062873;font-weight:700>&#34;id&#34;</span>: <span style=color:#40a070>100</span>,
</span></span><span style=display:flex><span>        <span style=color:#062873;font-weight:700>&#34;age&#34;</span>: <span style=color:#40a070>30</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:#062873;font-weight:700>&#34;history&#34;</span>: {
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note here that the first and last elements in the <code>people</code> array both
have an <code>id</code> of <code>100</code>. Our expression would then select the first
element that matched.</p><p>Finally, it&rsquo;s worth mentioning there is more than one way to write this
expression. In this example we&rsquo;ve decided that after we filter the list
we&rsquo;re going to select the value of the <code>general</code> key and then select
the first element in that list. We could also reverse the order of those
operations, we could have taken the filtered list, selected the first
element, and then extracted the value associated with the <code>general</code> key.
That expression would be:</p><pre><code>people[?general.id==`100`] | [0].general
</code></pre><p>Both versions are equally valid.</p><h1 id=wiki-using-functions>Using Functions</h1><p>JMESPath functions give you a lot of power and flexibility when working with JMESPath expressions.
Below are some common expressions and functions used in JMESPath.</p><h2 id=wiki-sort_by>sort_by</h2><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value="sort_by(Contents, &Date)[*].{Key: Key, Size: Size}"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;Contents&#34;: [
    {
      &#34;Date&#34;: &#34;2014-12-21T05:18:08.000Z&#34;,
      &#34;Key&#34;: &#34;logs/bb&#34;,
      &#34;Size&#34;: 303
    },
    {
      &#34;Date&#34;: &#34;2014-12-20T05:19:10.000Z&#34;,
      &#34;Key&#34;: &#34;logs/aa&#34;,
      &#34;Size&#34;: 308
    },
    {
      &#34;Date&#34;: &#34;2014-12-20T05:19:12.000Z&#34;,
      &#34;Key&#34;: &#34;logs/qux&#34;,
      &#34;Size&#34;: 297
    },
    {
      &#34;Date&#34;: &#34;2014-11-20T05:22:23.000Z&#34;,
      &#34;Key&#34;: &#34;logs/baz&#34;,
      &#34;Size&#34;: 329
    },
    {
      &#34;Date&#34;: &#34;2014-12-20T05:25:24.000Z&#34;,
      &#34;Key&#34;: &#34;logs/bar&#34;,
      &#34;Size&#34;: 604
    },
    {
      &#34;Date&#34;: &#34;2014-12-20T05:27:12.000Z&#34;,
      &#34;Key&#34;: &#34;logs/foo&#34;,
      &#34;Size&#34;: 647
    }
  ]
}</textarea>
<textarea class=result readonly>[
  {
    &#34;Key&#34;: &#34;logs/baz&#34;, &#34;Size&#34;: 329
  }, {
    &#34;Key&#34;: &#34;logs/aa&#34;, &#34;Size&#34;: 308
  }, {
    &#34;Key&#34;: &#34;logs/qux&#34;, &#34;Size&#34;: 297
  }, {
    &#34;Key&#34;: &#34;logs/bar&#34;, &#34;Size&#34;: 604
  }, {
    &#34;Key&#34;: &#34;logs/foo&#34;, &#34;Size&#34;: 647
  }, {
    &#34;Key&#34;: &#34;logs/bb&#34;, &#34;Size&#34;: 303
  }
]</textarea></div><p>The first interesting thing here if the use of the function <code>sort_by</code>.
In this example we are sorting the <code>Contents</code> array by the value of each
<code>Date</code> key in each element in the <code>Contents</code> array. The <code>sort_by</code>
function takes two arguments. The first argument is an array, and the
second argument describes the key that should be used to sort the array.</p><p>The second interesting thing in this expression is that the second
argument starts with <code>&</code>, which creates an expression type. Think of
this conceptually as a reference to an expression that can be evaluated
later. If you are familiar with lambda and anonymous functions,
expression types are similar. The reason we use <code>&Date</code> instead of
<code>Date</code> is because if the expression is <code>Date</code>, it would be evaluated
before calling the function, and given there&rsquo;s no <code>Date</code> key in the
outer hash, the second argument would evaluate to <code>null</code>. Check out
<code>function-evaluation</code>{.interpreted-text role=&ldquo;ref&rdquo;} in the specification
for more information on how functions are evaluated in JMESPath. Also,
note that we&rsquo;re taking advantage of the fact that the dates are in ISO
8601 format, which can be sorted lexicographically.</p><p>And finally, the last interesting thing in this expression is the <code>[*]</code>
immediately after the <code>sort_by</code> function call. The reason for this is
that we want to apply the multiselect hash, the second half of the
expression, to each element in the sorted array. In order to do this we
need a projection. The <code>[*]</code> does exactly that, it takes the input array
and creates a projection such that the multiselect hash
<code>{Key: Key, Size: Size}</code> will be applied to each element in the list.</p><p>There are other functions that take expression types that are similar to
<code>sort_by</code> including <a href=https://jmespath.site/#functions-min_by target=_blank rel=noopener><code>min_by</code></a>
and <a href=https://jmespath.site/#functions-max_by target=_blank rel=noopener><code>max_by</code></a>
.</p><h1 id=wiki-pipes>Pipes</h1><p>Pipe expression are useful for stopping projections. They can also be
used to group expressions.</p><h2 id=wiki-main-page>Main Page</h2><p>Let&rsquo;s look at a modified version of the expression on the <a href=https://jmespath.org target=_blank rel=noopener>JMESPath front page</a>
.</p><div class=demo onclick=demo(event)><input type=text class=query oninput=demoInput(event) value="locations[?state == 'WA'].name | sort(@)[-2:] | {WashingtonCities: join(', ', @)}"></input>
<textarea class=data rows=10 oninput=demoInput(event)>{
  &#34;locations&#34;: [
    {
      &#34;name&#34;: &#34;Seattle&#34;,
      &#34;state&#34;: &#34;WA&#34;
    },
    {
      &#34;name&#34;: &#34;New York&#34;,
      &#34;state&#34;: &#34;NY&#34;
    },
    {
      &#34;name&#34;: &#34;Bellevue&#34;,
      &#34;state&#34;: &#34;WA&#34;
    },
    {
      &#34;name&#34;: &#34;Olympia&#34;,
      &#34;state&#34;: &#34;WA&#34;
    }
  ]
}</textarea>
<textarea class=result readonly>{
  &#34;WashingtonCities&#34;: &#34;Olympia, Seattle&#34;
}</textarea></div><p>We can think of this JMESPath expression as having three components,
each separated by the pipe character <code>|</code>. The first expression is
familiar to us, it&rsquo;s similar to the first example on this page. The
second part of the expression, <code>sort(@)</code>, is similar to the <code>sort_by</code>
function we saw in the previous section. The <code>@</code> token is used to refer
to the current element. The <a href=https://jmespath.site/#functions-sort target=_blank rel=noopener><code>sort</code></a>
function takes a single parameter which is an array. If the input JSON
document was a hash, and we wanted to sort the <code>foo</code> key, which was an
array, we could just use <code>sort(foo)</code>. In this scenario, the input JSON
document is the array we want to sort. To refer to this value, we use
the current element, <code>@</code>, to indicate this. We&rsquo;re also only taking a
subset of the sorted array. We&rsquo;re using a slice (<code>[-2:]</code>) to indicate
that we only want the last two elements in the sorted array to be passed
through to the final third of this expression.</p><p>And finally, the third part of the expression,
<code>{WashingtonCities: join(', ', @)}</code>, creates a multiselect hash. It
takes as input, the list of sorted city names, and produces a hash with
a single key, <code>WashingtonCities</code>, whose values are the input list
(denoted by <code>@</code>) as a string separated by a comma.</p></main><footer></footer></body></html>