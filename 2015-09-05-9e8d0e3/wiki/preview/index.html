<!doctype html><html><head><meta charset=utf-8><title>JMESPath</title><link href=https://unpkg.com/sanitize.css rel=stylesheet><link rel=stylesheet href=https://jmespath.site/main.min.91cbf3ca4c1cba014f52fb1cabc8b45c0907041c88f3270cff97db422897cb94.css integrity="sha256-kcvzykwcugFPUvscq8i0XAkHBByI8ycM/5fbQiiXy5Q="><link rel=stylesheet href=https://jmespath.site/demo.min.9a8314c8ba82c1fec46ad930f6cfe86547c0237ae0064c1ee53b829948fd408f.css integrity="sha256-moMUyLqCwf7Eatkw9s/oZUfAI3rgBkwe5TuCmUj9QI8="><script src=https://cdnjs.cloudflare.com/ajax/libs/jmespath/0.16.0/jmespath.min.js integrity="sha512-w/sNKK/59oJUi6v+SjgfIijrkFN8Pfv5QFZSV4KvrNMJrlbVM3017ZGNCA2AwZ6PKJzTPxQaDs/TbPcVGnF+pQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://jmespath.site/demo.4c957ecc07ed2ed828e0dc71aa5c6708320dd533dbac0cdb7f52e532cea8e4ce.js integrity="sha256-TJV+zAftLtgo4NxxqlxnCDIN1TPbrAzbf1LlMs6o5M4="></script></head><body><header></header><main><h1 id=wiki-lexical-scopes>Lexical Scopes</h1><p>JMESPath Community introduces the <a href=https://github.com/jmespath-community/jmespath.spec/discussions/24 target=_blank rel=noopener><code>let()</code></a>
function
to supports nested lexical scopes.</p><pre tabindex=0><code>any let(object scope, expression-&gt;any expr)
</code></pre><p>The first argument is a JSON object that introduces a new lexical scope.</p><p>The second argument is an <code>expression-type</code> that is evaluated against the current context â€“ <em>i.e</em> the current result of JMESPath evaluation context, that can be referred to by the <code>@</code> node. The <code>expression-type</code> also has access to the stack of nested scopes.</p><p>Consider the following example:</p><div class="demo active" onclick=demoPreview(event) class=active><input type=text class=query oninput=demoInputPreview(event) value="let( {first_choice: first_choice}, &states[?name==first_choice].cities[] )"></input>
<textarea class=data rows=10 oninput=demoInputPreview(event)>{&#34;first_choice&#34;: &#34;WA&#34;,
 &#34;states&#34;: [
   {&#34;name&#34;: &#34;WA&#34;, &#34;cities&#34;: [&#34;Seattle&#34;, &#34;Bellevue&#34;, &#34;Olympia&#34;]},
   {&#34;name&#34;: &#34;CA&#34;, &#34;cities&#34;: [&#34;Los Angeles&#34;, &#34;San Francisco&#34;]},
   {&#34;name&#34;: &#34;NY&#34;, &#34;cities&#34;: [&#34;New York City&#34;, &#34;Albany&#34;]}
 ]
}</textarea>
<textarea class=result readonly>[&#34;Seattle&#34;,&#34;Bellevue&#34;,&#34;Olympia&#34;]</textarea></div><p>When evaluating the <code>states</code> identifier, JMESPath no longer has access to the root scope, where <code>first_choice</code> is defined. Therefore, under normal circumstances, the <code>filter-expression</code> <code>[?name === first_choice]</code> would evaluate the <code>first_choice</code> identifier and return an empty array.</p><p>Instead, <code>let()</code> defined the identifier <code>first_choice</code> has taking the value of the property with the same name in the input JSON document. It effectively created a scope that can be represented as the following JSON object:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{ <span style=color:#062873;font-weight:700>&#34;first_choice&#34;</span>: <span style=color:#4070a0>&#34;WA&#34;</span> }
</span></span></code></pre></div><p>Therefore, when evaluating the <code>filter-expression</code>, the <code>first_choice</code> identifier is indeed defined, and produces the correct result.</p></main><footer></footer></body></html>